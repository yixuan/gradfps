# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

gradfps_prox_ <- function(S, x0, d, lambda, lr, mu, r1, r2, maxiter = 500L, fan_maxinc = 100L, fan_maxiter = 10L, eps_abs = 1e-3, eps_rel = 1e-3, verbose = 0L) {
    .Call(`_gradfps_gradfps_prox_`, S, x0, d, lambda, lr, mu, r1, r2, maxiter, fan_maxinc, fan_maxiter, eps_abs, eps_rel, verbose)
}

gradfps_prox_benchmark_ <- function(S, Pi, x0, d, lambda, lr, mu, r1, r2, maxiter = 500L, fan_maxinc = 100L, fan_maxiter = 10L, eps_abs = 1e-3, eps_rel = 1e-3, verbose = 0L) {
    .Call(`_gradfps_gradfps_prox_benchmark_`, S, Pi, x0, d, lambda, lr, mu, r1, r2, maxiter, fan_maxinc, fan_maxiter, eps_abs, eps_rel, verbose)
}

gradfps_prox_omd_ <- function(S, x0, d, lambda, delta, lr, mu, r1, r2, maxiter = 500L, fan_maxinc = 100L, fan_maxiter = 10L, eps_abs = 1e-3, eps_rel = 1e-3, verbose = 0L) {
    .Call(`_gradfps_gradfps_prox_omd_`, S, x0, d, lambda, delta, lr, mu, r1, r2, maxiter, fan_maxinc, fan_maxiter, eps_abs, eps_rel, verbose)
}

gradfps_subgrad_ <- function(S, x0, d, lambda, lr, mu, r1, r2, maxiter = 500L, eps_abs = 1e-3, eps_rel = 1e-3, verbose = 0L) {
    .Call(`_gradfps_gradfps_subgrad_`, S, x0, d, lambda, lr, mu, r1, r2, maxiter, eps_abs, eps_rel, verbose)
}

gradfps_subgrad_benchmark_ <- function(S, Pi, x0, d, lambda, lr, mu, r1, r2, maxiter = 500L, eps_abs = 1e-3, eps_rel = 1e-3, verbose = 0L) {
    .Call(`_gradfps_gradfps_subgrad_benchmark_`, S, Pi, x0, d, lambda, lr, mu, r1, r2, maxiter, eps_abs, eps_rel, verbose)
}

#' Proximal operator on Fantope
#'
#' This function solves the optimization problem
#' \deqn{\min\quad-tr(AX) + \frac{1}{2\alpha}||X - B||_F^2}{min  -tr(AX) + (0.5 / \alpha) * ||X - B||_F^2}
#' \deqn{s.t.\quad X\in \mathcal{F}^d}{s.t. X in F^d}
#'
#' @param A       A symmetric matrix.
#' @param B       A symmetric matrix of the same dimension as \code{A}.
#' @param alpha   Proximal parameter.
#' @param d       Fantope parameter.
#' @param eps     Precision of the result.
#' @param inc     How many incremental eigenvalues to compute in each iteration.
#' @param maxiter Maximum number of iterations.
#' @param verbose Level of verbosity.
prox_fantope <- function(A, B, alpha, d, eps = 1e-5, inc = 1L, maxiter = 10L, verbose = 0L) {
    .Call(`_gradfps_prox_fantope`, A, B, alpha, d, eps, inc, maxiter, verbose)
}

#' Proximal operator of squared Lp norm
#'
#' This function solves the optimization problem
#' \deqn{\min\quad\frac{1}{2}||x||_p^2 + \frac{1}{2\alpha}||x - v||^2}{min  0.5 * ||x||_p^2 + (0.5 / \alpha) * ||x - v||^2}
#'
#' @param v       A numeric vector.
#' @param V       A symmetric matrix.
#' @param p       Norm parameter.
#' @param alpha   Proximal parameter.
#' @param eps     Precision of the result.
#' @param maxiter Maximum number of iterations.
#' @param verbose Level of verbosity.
#'
prox_lp <- function(v, p, alpha, eps = 1e-6, maxiter = 100L, verbose = 0L) {
    .Call(`_gradfps_prox_lp`, v, p, alpha, eps, maxiter, verbose)
}

#' @rdname prox_lp
#'
prox_lp_mat <- function(V, p, alpha, eps = 1e-6, maxiter = 100L, verbose = 0L) {
    .Call(`_gradfps_prox_lp_mat`, V, p, alpha, eps, maxiter, verbose)
}

lambda_range <- function(S, d, act_size_min, act_size_max) {
    .Call(`_gradfps_lambda_range`, S, d, act_size_min, act_size_max)
}

active_set <- function(S, d, lambda) {
    .Call(`_gradfps_active_set`, S, d, lambda)
}

